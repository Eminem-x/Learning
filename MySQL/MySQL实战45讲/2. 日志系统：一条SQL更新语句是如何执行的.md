# 2. 日志系统：一条SQL更新语句是如何执行的

第一讲中介绍了一条查询语句的执行过程，那么一条更新语句的执行流程又是怎样的呢？

在 MySQL 的介绍中提到<strong>数据可以恢复到半个月内任意一秒的状态</strong>，那么是怎样做到的呢？

先从一个表的一条更新语句说起，下面是建表语句和更新语句：

```shell
mysql> create table T(ID int primary key, c int);
mysql> update T set c=c+1 where ID=2;
```

同查询语句一样，更新语句也是同样会走一遍 server 和存储引擎层，

前面也提到过，如果在一个表上有更新的时候，跟着个表有关的查询缓存会失效，所以也是建议一般不使用查询缓存的原因。

<strong>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，redo log（重做日志）和 binlog（归档日志）。</strong>

## redo log

以《孔乙己》文章为例，酒店掌柜有一个粉板，专门用来记录客人的赊账记录，如果赊账的人不多，那么可以将顾客名和账目写在板上，

但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。

如果有人要赊账或者还账的话，掌柜一般有两种做法：

* 直接把账本翻出来，把这次的记录加上或者扣掉
* 先在粉板上记下这次的账，等打烊后再把账本翻出来核算

在生意红火的时候，掌柜一定选择后者，因为前者操作太耗时了，首先需要在账本里找到对应的记录，

然后还需要拿出算盘计算，最后再将结果写回到账本上，这是非常麻烦耗的，并且容易出错，

相比之下，先在粉板上记一下比较方便，并且在粉板的帮助下，效率也提高了很多。

同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到相对应的记录，

然后再更新 record，整个过程 IO 成本、查找成本都很高，为了解决这个问题，MySQL 采用了类似掌柜的做法。

<strong>粉板和账本配合的整个过程，就是 MySQL 里经常说到的 WAL 技术（Write-Ahead Logging），</strong>

它的关键是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。

> 需要注意的是，「先写日志」也是先写磁盘，只是写日志是顺序写盘，速度很快。
>
> 详细说明：先写 redo log 到 log buffer，具体内容就是针对哪个表空间的哪些页面做了哪些修改，
>
> 然后 log buffer 中的日志内容会在某些时候写到 redo 日志文件中，比如事务提交时。
>
> 至于为什么写 redo 日志会比刷新内存中的数据页中到磁盘快，是因为服务器在启动过的时候就已经给 redo 日志文件，
>
> 分配好了一块物理上的连续磁盘空间，每次写 redo 日志 都是往文件中追加写，并没有寻址的过程，
>
> 而修改过的数据页要刷新到磁盘的话，可能对应的磁盘空间并不是连续的，寻址起来需要消耗时间。
>
> 也是一个小技巧：将全局的随机写，变换为局部的顺序写，

具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会把记录写到 redo log（粉板）里面，并更新内存，

此时就算更新完成了，同时 InnoDB 引擎会在适当时候见这个操作记录更新到磁盘里面，往往是系统比较空闲的时候。

如果今天赊账不多，掌柜可以等打烊后再整理，但如果某天赊账特别多，粉板写满了，又怎么办呢？

掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，腾出新空间。

与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，

那么总共可以记录 4GB 的操作，从头开始写，写到末尾就又回到开头循环，如下图所示：

<img src="https://raw.githubusercontent.com/Eminem-x/Learning/main/MySQL/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/pic/redo%20log.jpg" style="max-width: 70%">

write pos 是当前记录的位置，一边写一边后移，如此反复循环，checkpoint 是当前要擦除的位置，

擦出记录前要把记录更新到数据文件，也就是把记录更新到磁盘上。

wirte pos 和 checkpoint 之间的空闲部分，可以用来记录新的操作，如果 write pos 追上 checkpoint，

表示记录已经满了，这时候不能再执行新的更新，需要先停下来，把 checkpoint 推进一下。

> 此处有额外的刷盘机制，避免 redo log 满了才刷盘，影响更新效率。

有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>，

依然借用掌柜的例子，如果店铺打烊了，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目，

好比数据库重启了，内存中的数据也没有同步到磁盘中，可以通过 redo log 日志恢复。

## binlog

> binlog 有三种记录模式：
>
> * statement 格式：记录 sql 语句
> * row 格式：记录行内容，记两条（更新前和更新后）
> * mixed 格式：前两种混合种，可以根据语句不同而自动选择合适的日志格式

<strong>上文提到的 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。</strong>

为什么会有两份日志呢？因为最开始 MySQL 里并没有 InnoDB 引擎，自带的引擎是 MyISAM，并没有 crash-safe 的能力，

binlog 日志只能用于归档，而 InnoDB 是另一个公司以插件形式引入 MySQL 的。

这两种日志有以下三点不同：

1. redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用
2. redo log 是物理日志，记录在某个数据页上做了什么修改；binlog 是逻辑日志，记录语句的原始逻辑
3. redo log 是循环写入，binlog 是追加写入，不会覆盖以前的日志

有了上述概念后，再来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程：

1. 执行器先找引擎区 ID = 2 这一行，ID 是主键，引擎直接用树搜素找到这一行，如果 ID = 2 这一行在内存中，

    就直接返回给执行器；否则需要先从磁盘读入内存，然后再返回。

2. 执行器拿到引擎给的行数据，把这个值更新，得到新的一行数据，在调用引擎接口写入这行新数据。

    > server 层调用引擎的更新接口，引擎在更新后，会先 redo log，此时处于 redo log 的 prepare 阶段，
    >
    > 然后 server 层写入 binlog 日志后，可以调用引擎的事务提交接口，由引擎把 redo log 改为提交状态。

3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里，此时 redo log 处于 prepare 状态，

    然后告知执行器执行完成了，随时可以提交事务。

4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。

5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成 commit 状态，更新完成。

<strong>将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是「两阶段提交」。</strong>

<img src="https://raw.githubusercontent.com/Eminem-x/Learning/main/MySQL/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/pic/update%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" style="max-width: 70%">

## 两阶段提交

为什么需要两阶段提交？这是为了让两份日志之间的逻辑一致，以达到让数据库恢复到半个月内任意一秒的状态。

前面我们说过了，binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。

如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，

同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。

当需要恢复到指定的某一秒时，可以如下操作：

* 首先找到最近的一次全量备份，从这个备份恢复到临时库
* 然后从备份的时间点开始，将备份的 binlog 依次取出来，重放到想要恢复的时间点之前

这样临时库就跟误删之前的线上库一样了，然后可以把表数据从临时库取出来，按需要恢复到线上库。

<strong>为什么日志需要两阶段提交，不妨用反证法来进行解释：</strong>

由于 redo log 和 binlog 时两个独立的逻辑，如果不用两阶段提交，要么是前者先要么是后者先，

假设在写完第一个日志后，第二个日志之前发生了 crash，会出现什么情况，分类讨论：

1. <strong>先写 redo log 后写 binlog。</strong>假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。

    redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但由于 binlog 没写完就 crash，

    这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后会发现，

    如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，

    这个临时库就会少了这一次更新恢复出来的这一行 c 的值就是 0，与原库的值不同。

2. <strong>先写 binlog 后写 redo log。</strong>如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，

    所以这一行 c 的值是 0，但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。

    所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。

<strong>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</strong>

尽管平时没有动不动就需要恢复临时库的场景，但是需要扩容的时候，目前常见的是全量备份 + binlog 来实现，

此时这个「不一致」就会导致线上出现主从数据库不一致的情况。

两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案，即使不做数据库内核开发，日常开发中也有可能会用到。

## 小结

物理日志 redo log 和逻辑日志 binlog：

redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，

表示每次事务的 redo log 都直接持久化到磁盘。这个参数建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失；

sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘，

这个参数也建议设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。

>Redo log不是记录数据页“更新之后的状态”，而是记录这个页 “做了什么改动”。
>
>SQL是面向用户的语义化命令，可以理解为高级编程语言。高级编程语言最终会被执行去完成磁盘上数据的操作。
>
>redo log记录的是磁盘上数据的物理变化，binlog记录的是当时所执行的高级编程语言。
>
>比如备份的时候记录 table 中字段 a 的值是 1→3（由 1 变成 3），而 binlog 里面记录可能就是多条 SQL 执行之后 a 的值才等于 3，
>
>比如 update table set a =1 where ID=1；update table set a=3 where ID=1；或者执行过更多 SQL 才变成 3。