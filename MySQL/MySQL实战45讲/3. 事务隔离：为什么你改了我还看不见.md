# 3. 事务隔离：为什么你改了我还看不见

简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。

在 MySQL 中，事务支持是在引擎层实现的，MySQL 支持多引擎，但并不是所有的引擎都支持事务，

比如 MySQL 生的 MyISAM 引擎就不支持事务，这也是其被 InnoDB 取代的重要原因之一。

### 隔离性与隔离级别

事务特性： ACID（Atomicity、Consistencey、Isolation、Durability）原子性、一致性、隔离性、持久性，

当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、

幻读（phantom read）的问题，为了解决这些问题，就有了「隔离级别」的概念。

隔离级别越高，数据库效率就会越低，安全性会越高，因此很多时候需要在二者之间寻找一个平衡点，

SQL 标准的事务隔离级别包括：

* 读未提交（read uncommitted）：一个事务还未提交时，它做的改变能够被其他事务看到
* 读提交（read committed）：一个事务提交之后，它做的变更才能被其他事务看到
* 可重复读（repeatable read）：一个事务执行过程中看到的数据，总是和启动时是一致的，并且其他事务不可见更改
* 串行化（serializable）：对同一行记录会加写锁、读锁，当读写冲突的时候，后访问的事务必须等待前一个执行完成

用下面这个例子，来解释这几种隔离级别，按照时间顺序执行两个事务：

|         事务 A         |    事务 B    |
| :--------------------: | :----------: |
| 启动事务，查询得到值 1 |   启动事务   |
|                        | 查询得到值 1 |
|                        | 将 1 改成 2  |
|     查询得到值 V1      |              |
|                        |  提交事务 B  |
|     查询得到值 V2      |              |
|       提交事务 A       |              |
|     查询得到值 V3      |              |

接下来看看在不同的隔离级别下，事务 A 会有哪些不同的返回结果，也就是 V1、V2、V3 的返回值分别是什么？

* 读未提交：V1 的值就是 2，这时候事务 B 虽然未提交，但是 A 可以看到，因此 V2、V3 也是 2

* 读提交：V1 是 1，V2、V3 是 2，因为事务 B 的更新在提交后才能被 A 看到

* 可重复读：V1，V2 的值是 1，V3 是 2，事务 B 的更新在提交后才能被 A 看到，事务执行期间看到数据前后一致

* 串行化：事务 A 拿到读锁，根据两阶段加锁，事务 A 获得的锁要在 commit 的时候才释放，

    所以事务 B 在修改1为2的时候申请写锁会阻塞直到事务 A 提交，事务A提交之前获取的值都是 1，所以 V1、V2 都是 1，

    事务 A 提交后事务 B 获取到写锁完成更新操作，所以 V3 是 2

实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准：

* RU 下，直接返回记录上的最新值
* RC 下，视图是在每个 SQL 语句开始执行的时候创建
* RR 下，视图是在事务启动时创建的，整个事务存在期间都用这个视图
* Serial 下，直接加锁方式避免并行访问

> 在不同的隔离级别下，数据库行为是有所不同的，Oracle 数据库的默认隔离级别是 RC，
>
> 因此对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别一致，要将 MySQL 的隔离级别设置为 RC。

配置的方式是，将启动参数 transaction-isolation 的值设置成 READ-COMMITTED，可以用 show variables 来查看当前的值。

### 事务隔离的实现

MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作，记录上的最新值，通过回滚操作，都可以得到前一个状态的值，

假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。

<img src="https://raw.githubusercontent.com/Eminem-x/Learning/main/MySQL/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/pic/%E5%9B%9E%E6%BB%9A%E6%AE%B5.jpg" style="max-width: 70%">

在视图 A、B、C ，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC），

对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。

回滚日志 undo log 不会一直保留，当在不需要的时候就会被删除，系统会判断当前有无事务再需要用到这些回滚日志，

什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 read-view 的时候。

<strong>基于上面的说明，建议不要使用长事务。</strong>

长事务意味着系统里面会存在很老的事务视图，由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，

数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间，

除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。

### 事务的启动方式

MySQL 的事务启动方式有以下两种：

* 显示启动事务语句，begin 或 start transaction，提交语句 commit，回滚语句 rollback
* set autocommit=0，这个命令会将这个线程的自动提交关闭

有些客户端连接框架会默认连接成功后先执行一个 set autocommit=0 的命令，

这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务，

因此，建议总是使用 set autocommit=1, 通过显式语句的方式来启动事务。

> 需注意，长连接并不意味着长事务，需要判断是否将 autocommit 设置成了 0。

可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务：

```sql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

