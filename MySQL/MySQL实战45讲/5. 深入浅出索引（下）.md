# 5. 深入浅出索引（下）

下面是一个表的初始化语句：

````shell
mysql> create table T (
ID int primary key,
k int NOT NULL DEFAULT 0, 
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
````

如果执行 select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？

1. 在 k 索引树上找到 k = 3 的记录，得到 ID = 300
2. 再到 ID 索引树查到 ID = 300 对应的 record
3. 在 k 索引树上找到 k = 5 的记录，得到 ID = 500
4. 再到 ID 索引树查到 ID = 500 对应的 record
5. 在 k 索引树上取下一个值 k = 6，不满足条件，循环结束

在这个过程中，回到主键索引树搜索的过程，称为回表，这个过程中查询 k 索引树 3 条记录，回表了两次。

由于查询结果所需要的数据只有在主键索引上有，所以不得不回表，那么有没有可能经过索引优化，避免回表过程？

## 覆盖索引

如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查询 ID 的值，而 ID 的值已经在 k 索引树上了，

<strong>因此可以直接提供查询结果，不需要回表，也就是说在这个查询里，索引 k 已经覆盖了查询需求，称为覆盖索引。</strong>

需要注意的是，在引擎内部使用覆盖索引在索引 k 上其实读了三个记录，R3~R5（对应的索引 k 上的记录项），

但是对于 MySQL 的 Server 层来说，它就是找引擎拿到了两条记录，因此 MySQL 认为扫描行数是 2。

基于上面覆盖索引的说明，讨论一个问题：在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？

> 联合索引相关文章：https://zhuanlan.zhihu.com/p/110427099、https://cloud.tencent.com/developer/news/44861

假设这个市民表的定义如下：

```sql
CREATE TABLE `tuser` (
  `id` int(11) NOT NULL,
  `id_card` varchar(32) DEFAULT NULL,
  `name` varchar(32) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `ismale` tinyint(1) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `id_card` (`id_card`),
  KEY `name_age` (`name`,`age`)
) ENGINE=InnoDB
```

身份证号是市民的唯一标识，也就是说，如果有根据身份证号查询市民信息的需求，

只要在身份证号字段上建立索引就够了，而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？

>给 id_card 和 name 建立联合索引后，name 的值也会被保存在 id_card 索引树的节点上，
>
>这样根据给定 id_card 的值找到的对应行时，就可以直接获取到 name 了，而不需要拿着对应的主键再进行回表操作。

如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。

它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。

当然，索引字段的维护总是有代价的，因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。

## 最左前缀原则

如果我现在要按照市民的身份证号去查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，

但总不能让它走全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费，应该怎么做呢？

<strong>B+ 树这种索引结构，可以利用索引的「最左前缀」，来定位记录。</strong>

<img src="https://raw.githubusercontent.com/Eminem-x/Learning/main/MySQL/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/pic/%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E7%A4%BA%E4%BE%8B.jpg" style="max-width: 70%">

可以看到，索引项是按照索引定义里面出现的字段顺序排序的，

如果第一个字段有相同的，就按照第二个字段排序，注意，这里仅仅有相同的第一个字段情况下，才会根据第二个字段排序。

* 当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果

* 如果你要查的是所有名字第一个字是“张”的人， SQL 语句的条件是 "where name like ‘张 %’"，

    这时，也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止

可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索，

这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。

> 比如 (a,b,c) a、ab、abc 都可以，但是 ac 不支持；存在特殊情况 select a、b、c from ac 称为索引覆盖

基于上面对最左前缀索引的说明，讨论一个问题：在建立联合索引的时候，如何安排索引内的字段顺序。

这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，

一般就不需要单独在 a 上建立索引了。因此，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。

那么，如果既有联合查询，又有基于 a、b 各自的查询呢？查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，

这时候不得不维护另外一个索引，也就是说你需要同时维护 (a,b)、(b) 这两个索引。

<strong>这时候，要考虑的原则就是空间了。</strong>

比如上面这个市民表的情况，name 字段是比 age 字段大的 ，那就建议创建一个（name,age) 的联合索引和一个 (age) 的单字段索引。

## 索引下推

那些不符合最左前缀的部分，会怎么样呢？

还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。

那么，SQL 语句是这么写的：

```sql
mysql> select * from tuser where name like '张%' and age=10 and ismale=1;
```

根据前缀索引规则，该语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录 ID3，这还不错，总比全表扫描要好，

接下来要做的是判断其他条件是否满足，在 MySQL 5.6 之前，只能从 ID3 开始一个个回表，到主键索引上找出数据行，再对比字段值，

而 MySQL 5.6 引入的索引下推优化， 在索引遍历过程中，对索引中包含字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

<strong>即 InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。</strong>

>mysql 会一直向右匹配直到遇到范围查询（>、<、between、like）就停止匹配。
>
>范围列可以用到索引，但是范围列后面的列无法用到索引，
>
>即索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。

### 上期问题解答

> 通过两个 alter 语句重建索引 k，以及通过两个 alter 语句重建主键索引是否合理。
>
> ```sql
> alter table T drop index k;
> alter table T add index(k);
> ```

1. 为什么要考虑重建索引？

    索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，

    把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。

2. 重建索引是合理的，可以达到省空间的目的

3. 重建主键的过程不合理，不论是删除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做了

这两个语句，可以用这个语句代替 ： alter table T engine=InnoDB。