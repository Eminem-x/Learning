# 编译原理

### 编译过程

介绍三个比较重要的概念：抽象语法树、静态单赋值、指令集

1. <strong>抽象语法树</strong>：（abstract syntax tree, AST) 是源代码语法结构的一种抽象表示，用树状的方式表示编程语言的语法结构，

   作为编译器常用的数据结构，抽象语法树抹去了源代码中一些不重要的字符，如空格、分号、括号等，

   并且会辅助编译器进行语义分析，可以用它来确定语法正确的程序是否存在一些类型不匹配的问题。

2. <strong>静态单赋值</strong>：（static single assignment,SSA) 是中间代码的特性：中间代码中每个变量只会被赋值一次，

   因为 SSA 的主要作用是对代码进行优化，所以它是编译器后端的一部分。

3. <strong>指令集：</strong>开发过程中常遇到的情况「在本地开发环境编译和运行正常的代码在生产环境却无法正常工作」，原因有很多，

   而不同机器使用不同指令集可能是原因之一，容器的诞生也解决了这个令人头疼的问题，当然还有很多其他办法。

   `uname -m` 获得当前机器的硬件信息，x86、ARM 是比较常见的指令集，MacBook M1 芯片后一般是 ARM，

   不同的处理器使用不同的架构和机器语言，所以为了在不同的机器上运行，编程语言一般根据架构翻译成不同的机器代码。

   <strong>复杂指令集计算机(CISC)和精简指令集计算机(RISC)</strong>是两种遵循不同设计理念的指令集，二者没有绝对的优劣。

-----

编译器最重要的几个阶段：词法分析、语法分析、语义分析(类型检查)、中间代码生成、代码优化、代码生成(机器码生成)，

在逻辑上可以分成四个阶段：词法分析与语法分析、类型检查、中间代码生成、机器代码生成：

1. <strong>词法分析与语法分析</strong>：词法分析通过解析源代码文件，将文件中的字符串序列转换成 Token 序列，

   语法分析的输入是词法分析器（lexer）输出的 Token 序列，按照编程语言定义好的文法（grammer）顺序解析，生成语法树，

   <strong><em>Go 语言的语法分析器使用的是 `LALR(1)` 的文法</em></strong>

   每一个 Go 源代码文件最终会被归纳成一个 SourceFile 结构：由 package 定义，由多条 import 语句以及顶层声明组成，

   `SourceFile = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .`

   语法解析过程中发生的任何语法错误都会被语法分析器发现并将消息打印到 `Stdout`，编译过程也会随着错误出现而终止。

2. <strong>类型检查：</strong>拿到抽象语法树后，编译器会检查语法树中定义的使用类型，类型检查会按照以下顺序分别验证和处理不同类型的节点：

   * 常量、类型、函数名及其类型
   * 变量的赋值和初始化
   * 函数和闭包的主体
   * 哈希表键值对的类型
   * 导入函数体
   * 外部声明

   遍历整棵抽象语法树，在每个节点上都会验证当前子树的类型，以保证节点不存在类型错误。

   类型检查阶段不止会验证节点的类型，还会展开和改写一些内置函数，例如：make 关键字，

   类型检查这一过程在整个编译流程中非常重要，Go语言很多关键字依赖类型检查期间的改写。

3. <strong>中间代码生成：</strong>在类型检查后，编译器会通过 `cmd/compile/internal/gc.compileFunctions` 编译整个项目的函数，

   这些函数会在一个编译队列中等待几个 `goroutine` 消费，并发执行将所有函数对应的抽象语法树转换成中间代码，

   由于 Go 语言编译器的中间代码使用 SSA 的特性，所以在该阶段能够分析出无用变量和片段，并对其进行优化。

4. <strong>机器码生成：</strong>Go 语言源代码的 `src/cmd/compile/internal` 目录中包含了很多机器码生成相关的包，

   不同类型的 CPU 使用不同的包生成机器码，Go 语言经过编译几乎可以在所有主流机器上运行。

-------

Go 语言编译器的入口在 `src/cmd/compile/internal/gc/main.go` 其中 `Main` 函数就是 Go 语言编译器的主程序，

该程序会先获取命令行传入的参数并更新编译选项和配置，随后 `lines := parseFiles(flag.Args())` 进行词法、语法分析，

得到对应的抽象语法树，而后按照上述的流程进行编译检查，生成代码。
