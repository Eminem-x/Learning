### 程序结构

1. 关键字相比于 `Java` 数量较少，一些常见的常量、类型、函数都是预声明，可覆盖
2. 相比于 `Java` 的皆为对象，`Go` 中很少使用 `new`，并且其是一个预声明函数
3. 多重赋值：允许几个变量一次性被赋值，实际更新前，右边所有表达式被推演
4. 不要将作用域和生命周期混淆
   1. 声明的作用域是声明程序文本中出现的区域，是一个编译时属性
   2. 生命周期是变量在程序执行期间能被程序的其他部分所引用的起止时间，是一个运行时属性

5. 当编译器遇到一个名字的引用时，将从最内层的封闭词法块到全局块寻找声明
   1. 如果没有找到，`undeclared name` 错误
   2. 如果找到，内层声明将覆盖外部声明，但是覆盖也是在此内层块中

### 数据类型

1. 基础类型、聚合类型、引用类型、接口类型
   1. 基础类型：整数、浮点数、复数、字符串
   2. 聚合类型：数组、`slice`、`map`、结构体

2. `char` 类型可以用 `byte` 或者 `uint8` 表示
3. 浮点数有两种形式：`float32` 和 `float64`，通常推荐后者
4. 复数有两种形式：`complex64` 和 `complex128`，分别由上述两种浮点数构成
5. `bool` 和 `string` 类型用法以及不可变性基本和 `Java` 一致，除了名字不同
6. 四个标准包处理字符串：`bytes` 、`strings` 、`strconv` 、`unicode`
7. 数组类型可以直接比较，但必须确保是相同的数据类型和数组类型，并且数组元素可比较
8. 数组：`s := [...]int{0, 1, 2}`； `slice`: `s := []int{1, 2, 3`
9. 也可以通过 `make` 创建一个具有指定元素类型、长度和容量的 `slice` 其中容量参数可以省略：`make([] T, len, cap)`
10. `append` 添加元素，`delete` 删除键，注意 `slice` 和 `map` 不能直接比较
11. `if key, ok := hash[key]; ok` 判断是否存在，区别不存在和存在但值为零的情况
12. 如果一个结构体的成员变量名称是首字母大写的，那么这个变量是可导出的， 这个是 `Go` 最重要的访问控制机制，
    一个结构体可同时包含可导和不可导的成员变量
13. 出于效率的考虑，大型的结构体通常使用结构体指针的方式直接传递给函数或返回
14. 允许定义不带名称的结构体成员，只需要指定类型即可，匿名成员，也就是组合
15. `Go` 处理 `JSON` 数据很方便，有内置库：`encoding/json`

### 函数

1. `func name(param-list) (result-list) { body }`
2. 返回值可以像形参一样命名，每一个命名的返回值会声明为一个局部变量并初始化默认值
3. 如果看到函数的声明没有函数体，那么说明使用了非 `Go` 语言实现
4. `Go` 中函数的返回值可以有多个，如果返回值有命名，那么可以裸返回，更简洁，但保守使用
5. 如果当函数调用发生错误时返回一个附加的结果作为错误值，通常设置为布尔类型，是非常必要的
6. 函数变量的赋值，可以理解成函数地址，与 `C++` 中的用法似乎差不多
7. 匿名函数：参考原书 `120` ~ `123` 页
   命名函数只能在包级别的作用域进行声明，但能够使用函数字面量在任何表达式内指定函数变量。
   函数字面量就像函数声明，但在 `func` 关键字后面没有函数的名称，它是一个表达式，它的值称作匿名函数。
   函数变量类似于使用闭包方法实现的变量，因此把函数变量称为闭包。
8. 变长函数被调用的时候可以有可变的参数个数： `func name(vals ...T) (result-list) { body }`
9. `defer` 语句使得函数和参数表达式会在语句执行时求值，但在函数执行完毕后，以栈形式执行， 
   通常用于成对的操作，比如打开和关闭；以及资源的释放
10. 宕机 `panic` 和恢复 `recover` 机制和 `Java` 中的 `try catch` 其实差不多，不过具体上会有差异

### 方法

1. 即为结构体添加方法，但是不同于常用的 `class`，更偏向 `struct` 的用法

2. 习惯上遵循如果任何一个方法使用指针接收者，那么其所有方法都应使用指针接收者， 
   为防止混淆，不允许本身是指针的类型进行方法声明

3. 如果接收者不是指针类型，但是方法要求，依然可以调用方法，内部隐式转换，反之亦可
   但是`Point{1, 2}.f()`， 不能获得类型字面量的地址，发生编译错误，以下三种合法：

   1.  实参接收者和形参接收者是同一个类型
   2.  实参接收者是 `T` 类型的变量而形参接收者是 `*T` 类型
   3.  实参接收者是 `*T` 类型而形参接收者是 `T` 类型

1. 与 `Java` 不用的是，`nil` 是一个合法的接收者，但需要进行处理

5. 封装是面向对象编程的重要一方面，主要作用基本都是一致的， 
   `Go` 只有一种方式控制命名的可见性：定义的时首字母大写就是可导出，同样的机制也同样作用于结构体内的字段和类型中的方法，结论就是：要封装一个对象，必须使用结构体，
   另一个结论就是：封装的单元是包而不是类型，无论是函数内的代码还是方法内的代码，
   结构体类型内的字段对于同一个包中的所有代码都是可见的，封装的优点就不再赘述。

### 接口

1. `interface` 的定义以及功能和 `Java` 相似，但不需要声明实现了那些接口

1. 接口值分为两个部分：一个具体类型和该类型的一个值，二者成为接口的动态类型和动态值

1. 类型断言与 `Java` 中的 `instanceOf` 作用相似，判断对象是否为某种类型或者实现接口

1. 类型分支：`switch type` 语句，类型断言的增强版

1. 感觉接口部分很多概念都和其他语言相近，一些概念比较枯燥，在以后代码中实战学习

### goroutine和通道