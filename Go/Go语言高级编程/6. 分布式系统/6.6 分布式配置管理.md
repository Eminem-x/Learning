# 分布式配置管理

分布式系统中，常困扰我们的有线上问题，如何热部署、热配置生效，虽然目前有一些优雅重启方案，

但实际应用中可能受限于系统内部的运行情况而没有办法做到真正的优雅，比如为了对下游服务进行流量限制，

在内存中堆积一些数据，并对堆积设定时间或总量的阈值，在任意阈值达到之后将数据统一发送到下游，

以避免频繁的请求超出下游的承载能力而将下游打垮，这种情况下重启要做到优雅就比较难了。

## 使用 etcd 实现配置更新

#### 配置定义

简单的配置，可以将内容完全存储在 etcd 中。比如：

```shell
etcdctl get /configs/remote_config.json
{
    "addr" : "127.0.0.1:1080",
    "aes_key" : "01B345B7A9ABC00F0123456789ABCDAF",
    "https" : false,
    "secret" : "",
    "private_key_path" : "",
    "cert_file_path" : ""
}
```

#### 新建 etcd client

```go
cfg := client.Config{
    Endpoints:               []string{"http://127.0.0.1:2379"},
    Transport:               client.DefaultTransport,
    HeaderTimeoutPerRequest: time.Second,
}
```

直接用 etcd client 包中的结构体初始化，没什么可说的。

#### 配置获取

```go
resp, err = kapi.Get(context.Background(), "/path/to/your/config", nil)
if err != nil {
    log.Fatal(err)
} else {
    log.Printf("Get is done. Metadata is %q\n", resp)
    log.Printf("%q key has %q value\n", resp.Node.Key, resp.Node.Value)
}
```

获取配置使用 etcd KeysAPI 的 `Get()` 方法，比较简单。

#### 配置更新订阅

```go
kapi := client.NewKeysAPI(c)
w := kapi.Watcher("/path/to/your/config", nil)
go func() {
    for {
        resp, err := w.Next(context.Background())
        log.Println(resp, err)
        log.Println("new values is", resp.Node.Value)
    }
}()
```

通过订阅 config 路径的变动事件，在该路径下内容发生变化时，客户端侧可以收到变动通知，并收到变动后的字符串值。

#### 整合流程

```go
package main

import (
    "log"
    "time"

    "golang.org/x/net/context"
    "github.com/coreos/etcd/client"
)

var configPath =  `/configs/remote_config.json`
var kapi client.KeysAPI

type ConfigStruct struct {
    Addr           string `json:"addr"`
    AesKey         string `json:"aes_key"`
    HTTPS          bool   `json:"https"`
    Secret         string `json:"secret"`
    PrivateKeyPath string `json:"private_key_path"`
    CertFilePath   string `json:"cert_file_path"`
}

var appConfig ConfigStruct

func init() {
    cfg := client.Config{
        Endpoints:               []string{"http://127.0.0.1:2379"},
        Transport:               client.DefaultTransport,
        HeaderTimeoutPerRequest: time.Second,
    }

    c, err := client.New(cfg)
    if err != nil {
        log.Fatal(err)
    }
    kapi = client.NewKeysAPI(c)
    initConfig()
}

func watchAndUpdate() {
    w := kapi.Watcher(configPath, nil)
    go func() {
        // watch 该节点下的每次变化
        for {
            resp, err := w.Next(context.Background())
            if err != nil {
                log.Fatal(err)
            }
            log.Println("new values is", resp.Node.Value)

            err = json.Unmarshal([]byte(resp.Node.Value), &appConfig)
            if err != nil {
                log.Fatal(err)
            }
        }
    }()
}

func initConfig() {
    resp, err = kapi.Get(context.Background(), configPath, nil)
    if err != nil {
        log.Fatal(err)
    }

    err := json.Unmarshal(resp.Node.Value, &appConfig)
    if err != nil {
        log.Fatal(err)
    }
}

func getConfig() ConfigStruct {
    return appConfig
}

func main() {
    // init your app
}
```

如果业务规模不大，使用上面例子就可以实现功能了。

<strong>这里只需要注意一点，在更新配置时，进行了一系列操作：watch 响应，json 解析，这些操作都不具备原子性，</strong>

<strong>当单个业务请求流程中多次获取 config 时，有可能因为中途 config 发生变化而导致单个请求前后逻辑不一致，</strong>

<strong>因此，在使用类似这样的方式来更新配置时，需要在单个请求的生命周期内使用同样的配置，</strong>

具体实现方式可以是只在请求开始的时候获取一次配置，然后依次向下透传等等，具体情况具体分析。

## 配置膨胀

随着业务发展，配置系统本身所承载的压力可能会越来越大，配置文件可能成千上万，这时配置内容存储在 etcd 内部便不合适了，

随着配置文件数量的膨胀，除了存储系统本身的吞吐量问题，还有配置信息的管理问题，

需要对相应的配置进行权限管理，需要根据业务量进行配置存储的集群划分，

如果客户端太多，导致了配置存储系统无法承受瞬时大量的 QPS，那可能还需要在客户端侧进行缓存优化等等。

这也就是为什么大公司都会针对自己的业务额外开发一套复杂配置系统的原因。

## 配置版本管理

在配置管理过程中，难免出现用户误操作的情况，例如在更新配置时，输入了无法解析的配置。这种情况下可以通过配置校验来解决。

有时错误的配置可能不是格式上有问题，而是在逻辑上有问题。比如写 SQL 时少 select 了一个字段，更新配置时，

不小心丢掉了 json 字符串中的一个 field 而导致程序无法理解新的配置而进入诡异的逻辑，

为了快速止损，最快且最有效的办法就是进行版本管理，并支持按版本回滚。

在配置进行更新时，要为每份配置的新内容赋予一个版本号，并将修改前的内容和版本号记录下来，

当发现新配置出问题时，能够及时地回滚回来。

常见的做法是，使用 MySQL 来存储配置文件或配置字符串的不同版本内容，在需要回滚时，只要进行简单的查询即可。

## 客户端容错

尽管将配置中心单独抽离出，但并不意味着可以高枕无忧，需要客户端也具有一定的容错能力，保证配置服务宕机，依然可以正常运转，

这要求系统能够在配置中心宕机时，也能拿到需要的配置信息，哪怕这些信息不够新，

具体来讲，在给业务提供配置读取的 SDK 时，最好能够将拿到的配置在业务机器的磁盘上也缓存一份，

这样远程配置中心不可用时，可以直接用硬盘上的内容来做兜底，当重新连接上配置中心时，再把相应的内容进行更新。

加入缓存之后需要考虑的是数据一致性问题，当个别机器因为网络错误而与其它机器配置不一致时，也应该能够从监控系统中知晓。