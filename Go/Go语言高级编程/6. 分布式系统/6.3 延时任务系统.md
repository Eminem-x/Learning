# 延时任务系统

业务系统中，很多时候是处理实时的任务，请求来了马上处理，然后立刻给用户以反馈，但有时也会遇到非实时的任务，

比如确定的时间点发布重要公告，或者需要在用户做了一件事情的 X 小时 Y 分钟后，对其特定动作，比如通知、发券等等。

如果业务规模比较小，有时也可以通过数据库配合轮询来对这种任务进行简单处理，但上了规模的业务，

自然会寻找更为普适的解决方案来解决这一类问题，一般有两种思路来解决这个问题：

1. 实现一套类似 crontab 的分布式定时任务管理系统
2. 实现一个支持定时发送消息的消息队列

两种思路进而衍生出一些不同的系统，但本质都是相似的，都需要实现一个定时器（timer）。

## 定时器的实现

timer 的实现常见的就是时间堆和时间轮。

### 1. 时间堆

最常见的时间堆一般用小顶堆实现，其实就是一种特殊的二叉树：

<img src="https://raw.githubusercontent.com/Eminem-x/Learning/main/Go/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/pic/%E4%BA%8C%E5%8F%89%E5%A0%86.png" style="max-width: 60%">

小顶堆的好处是什么呢？对于定时器来说，如果堆顶元素比当前的时间还要大，那么说明堆内所有元素都比当前时间大,

进而说明这个时刻还没有必要对时间堆进行任何处理，定时检查的时间复杂度是 `O(1)`。

当发现堆顶的元素小于当前时间时，那么说明可能已经有一批事件已经开始过期了，这时进行堆调整操作，时间复杂度都是 `O(LgN)`。

<strong>Go 自身的内置定时器就是用时间堆来实现的，不过并没有使用二叉堆，而是使用了扁平一些的四叉堆：</strong>

<img src="https://raw.githubusercontent.com/Eminem-x/Learning/main/Go/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/pic/%E5%9B%9B%E5%8F%89%E5%A0%86.png" style="max-width: 70%">

父节点比其 4 个子节点都小，子节点之间没有特别的大小关系要求，四叉堆中元素超时和堆调整与二叉堆没有什么本质区别。

### 2. 时间轮

<img src="https://raw.githubusercontent.com/Eminem-x/Learning/main/Go/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/pic/%E6%97%B6%E9%97%B4%E8%BD%AE.png" style="max-width: 70%">

用时间轮来实现定时器时，需要定义每一个格子的「刻度」，可以将时间轮想像成一个时钟，中心有秒针顺时针转动，

每次转动到一个刻度时，我们就需要去查看该刻度挂载的任务列表是否有已经到期的任务。

从结构上来讲，时间轮和哈希表很相似，如果把哈希算法定义为：触发时间 % 时间轮元素大小，

那么这就是一个简单的哈希表，在哈希冲突时，采用链表挂载哈希冲突的定时器，除了单层时间轮，业界也有时间轮采用多层实现。

## 任务分发

当定时任务被触发之后需要通知用户侧，有两种思路：

1. <strong>将任务被触发的信息封装为一条消息，发往消息队列，由用户侧对消息队列进行监听</strong>
2. <strong>对用户预先配置的回调函数进行调用</strong>

两种方案各有优缺点：

* 如果采用消息队列，那么如果消息队列出故障会导致整个系统不可用，当然，现在的消息队列一般也会有自身的高可用方案，

  大多数时候我们不用担心这个问题。其次一般业务流程中间走消息队列的话会导致延时增加，定时任务若必须在触发后的几十毫秒

  几百毫秒内完成，那么采用消息队列就会有一定的风险

* 如果采用回调函数，会加重定时任务系统的负担，单机的定时器执行时最怕的就是回调函数执行时间过长，会阻塞后续的任务执行，

  在分布式场景下，这种忧虑依然是适用的，一个不负责任的业务回调可能就会直接拖垮整个定时任务系统，

  所以还要考虑在回调的基础上增加经过测试的超时时间设置，并且对由用户填入的超时时间做慎重的审核。

## 数据再平衡和幂等考量

当执行任务集群有机器故障时，需要对任务进行重新分配，使得整体流程可以正常进行，下面是一种思路。

可以参考 Elasticsearch 的数据分布设计，每份任务数据都有多个副本，这里假设两副本：

<img src="https://raw.githubusercontent.com/Eminem-x/Learning/main/Go/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/pic/%E4%BB%BB%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83.png" style="max-width: 60%">

<strong>一份数据虽然有两个持有者，但持有者持有的副本会进行区分，一个任务只会在持有主副本的节点上被执行。</strong>

当有机器故障时，任务数据需要进行数据再平衡的工作，将数据会被迁移到正常节点上。

当然，也可以用稍微复杂一些的思路，比如对集群中的节点进行角色划分，由协调节点来做这种故障时的任务重新分配工作，

考虑到高可用，协调节点可能也需要有 1 至 2 个备用节点以防不测。