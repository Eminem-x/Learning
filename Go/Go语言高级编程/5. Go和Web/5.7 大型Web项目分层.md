# 大型Web项目分层

目前 Web 框架大多数是 MVC 框架，为了能够对 GUI 类型的应用进行方便拓展，将程序划分为：

1. 控制器（Controller）：负责转发请求，对请求进行处理
2. 视图（View）：界面设计人员进行图形界面设计
3. 模型（Model）：编写应用的功能、进行数据管理和数据库设计

随着时代的发展，前段也变成了越来越复杂的工程，为了更好地工程化，现在更为流行的一般是前后端分离的架构，

可以认为前后分离是把 V 层从 MVC 中抽离单独成为项目，这样后端项目一般就只剩下 M 和 C 层了，

（不仅仅是项目分离，实际上也是将页面渲染交给浏览器而非后端处理后，再交给浏览器，减少服务端开销）

前后端之间通过 ajax 来交互，有时候也要解决跨域问题，但是目前已经比较成熟：

<img src="https://raw.githubusercontent.com/Eminem-x/Learning/main/Go/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/pic/mvc.png" style="max-width: 80%">

事实上，即使是简单的项目，业界也并没有完全遵守 MVC 框架提出者对于 M 和 C 所定义的分工，

有很多项目会在 Controller 层塞入大量的逻辑，在 Model 层就只管理数据的存储，

这往往来源于对于 model 层字面含义的某种擅自引申理解，认为这一层就是处理某种建模，而模型是什么？就是数据呗！

这是有问题的，业务流程也算是一种 “模型”，是对真实世界用户行为或者既有流程的一种建模，并非只有按格式组织的数据才能叫模型，

不过按照 MVC，如果把和数据打交道的代码还有业务流程全部塞进 MVC 里的 M 层的话，这个 M 层又会显得有些过于臃肿。

<strong>对于复杂的项目，一个 C 和一个 M 层显然是不够用的，现在比较流行的纯后端 API 模块一般采用下述划分方法：</strong>

1. Controller，与上述类似，服务入口，负责处理路由，参数校验，请求转发。

2. Logic/Service，逻辑（服务）层，一般是业务逻辑的入口，可以认为从这里开始，所有的请求参数一定是合法的，

   业务逻辑和业务流程也都在这一层中。常见的设计中会将该层称为 Business Rules。

3. DAO/Repository，主要负责和数据、存储打交道。将下层存储以更简单的函数、接口形式提供给上层，负责数据的持久化工作。

<img src="https://raw.githubusercontent.com/Eminem-x/Learning/main/Go/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/pic/cld.png" style="max-width: 80%">

划分为 CLD 三层之后，在 C 层之前我们可能还需要同时支持多种协议，

有时我们需要支持多种，比如同一个接口，我们既需要效率较高的 thrift，也需要方便 debug 的 http 入口，

<strong>即除了 CLD 之外，还需要一个单独的 protocol 层，负责处理各种交互协议的细节，这样请求的流程会变成下图：</strong>

<img src="https://raw.githubusercontent.com/Eminem-x/Learning/main/Go/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/pic/protocol_1.png" style="max-width: 80%">

协议细节处理这一层有大量重复劳动，每一个接口在协议这一层的处理，无非是把数据从协议特定的结构体 

(例如 `http.Request`，thrift 的被包装过了) 读出来，再绑定到协议无关的结构体上，再把这个结构体映射到 Controller 的结构体上，

代码都遵循着某种模式，那么可以对这些模式进行简单的抽象，用代码生成的方式，把繁复的协议处理代码从工作内容中抽离出去。

先来看看 HTTP 对应的结构体、thrift 对应的结构体和我们协议无关的结构体分别长什么样子：

```go
// http 请求结构体
type CreateOrder struct {
    OrderID   int64  `json:"order_id" validate:"required"`
    UserID    int64  `json:"user_id" validate:"required"`
    ProductID int    `json:"prod_id" validate:"required"`
    Addr      string `json:"addr" validate:"required"`
}

// thrift 请求结构体
type FeatureSetParams struct {
    DriverID  int64  `thrift:"driverID,1,required"`
    OrderID   int64  `thrift:"OrderID,2,required"`
    UserID    int64  `thrift:"UserID,3,required"`
    ProductID int    `thrift:"ProductID,4,required"`
    Addr      string `thrift:"Addr,5,required"`
}

// controller input struct
type CreateOrderParams struct {
    OrderID int64
    UserID int64
    ProductID int
    Addr string
}
```

我们需要通过一个源结构体来生成我们需要的 HTTP 和 thrift 入口代码。再观察一下上面定义的三种结构体，

只要能用一个结构体生成 thrift 的 IDL，以及 HTTP 服务的 “IDL（只要能包含 json 或 form 相关 tag 的结构体定义信息）” 就可以了。

这个初始的结构体我们可以把结构体上的 HTTP 的 tag 和 thrift 的 tag 揉在一起：

```go
type FeatureSetParams struct {
    DriverID  int64  `thrift:"driverID,1,required" json:"driver_id"`
    OrderID   int64  `thrift:"OrderID,2,required" json:"order_id"`
    UserID    int64  `thrift:"UserID,3,required" json:"user_id"`
    ProductID int    `thrift:"ProductID,4,required" json:"prod_id"`
    Addr      string `thrift:"Addr,5,required" json:"addr"`
}
```

虽然项目在入口支持了多种交互协议，但是还有一些问题没有解决，如果考虑中间件的话：

<img src="https://raw.githubusercontent.com/Eminem-x/Learning/main/Go/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/pic/protocol_2.png" style="max-width: 80%">

之前学习的中间件是和 HTTP 协议强相关的，但在 thrift 中没有和 HTTP 中对等的解决这些非功能性逻辑代码重复问题的中间件。