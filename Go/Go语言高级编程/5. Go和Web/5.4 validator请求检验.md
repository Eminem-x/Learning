# validator请求检验

社区里曾经用图来嘲笑 PHP：

<img src="https://raw.githubusercontent.com/Eminem-x/Learning/main/Go/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/pic/%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C.jpg" alt="system call" style="max-width: 70%">

这其实是一个语言无关的场景，需要进行字段校验的情况有很多，Web 系统的 Form 或 JSON 提交只是一个典型的例子。

以 Go 为例，复现上图的校验实例，然后一步步的对其进行改进：

````go
type RegisterReq struct {
    Username       string   `json:"username"`
    PasswordNew    string   `json:"password_new"`
    PasswordRepeat string   `json:"password_repeat"`
    Email          string   `json:"email"`
}

func register(req RegisterReq) error{
    if len(req.Username) > 0 {
        if len(req.PasswordNew) > 0 && len(req.PasswordRepeat) > 0 {
            if req.PasswordNew == req.PasswordRepeat {
                if emailFormatValid(req.Email) {
                    createUser()
                    return nil
                } else {
                    return errors.New("invalid email")
                }
            } else {
                return errors.New("password and reinput must be the same")
            }
        } else {
            return errors.New("password and password reinput must be longer than 0")
        }
    } else {
        return errors.New("length of username cannot be 0")
    }
}
````

这种代码一般怎么进行优化呢？很简单，在《重构》一书中已经给出了方案：[Guard Clauses](https://refactoring.com/catalog/replaceNestedConditionalWithGuardClauses.html)：

````go
func register(req RegisterReq) error{
    if len(req.Username) == 0 {
        return errors.New("length of username cannot be 0")
    }

    if len(req.PasswordNew) == 0 || len(req.PasswordRepeat) == 0 {
        return errors.New("password and password reinput must be longer than 0")
    }

    if req.PasswordNew != req.PasswordRepeat {
        return errors.New("password and reinput must be the same")
    }

    if emailFormatValid(req.Email) {
        return errors.New("invalid email")
    }

    createUser()
    return nil
}
````

代码更清爽，看起来也不那么别扭了。这是比较通用的重构理念。虽然使用了重构方法使得校验过程代码看起来优雅了，

但还是得为每一个 `http` 请求都去写这么一套 `validate()` 函数，有没有更好的办法来解除这项体力劳动？答案就是 validator。

## validator

地址仓库：https://github.com/go-playground/validator

```go
import "github.com/go-playground/validator/v10"

type RegisterReq struct {
    // 字符串的 gt=0 表示长度必须 > 0，gt = greater than
    Username       string   `validate:"gt=0"`
    // 同上
    PasswordNew    string   `validate:"gt=0"`
    // eqfield 跨字段相等校验
    PasswordRepeat string   `validate:"eqfield=PasswordNew"`
    // 合法 email 格式校验
    Email          string   `validate:"email"`
}

var validate = validator.New()

func validateFunc(req RegisterReq) error {
    err := validate.Struct(req)
    if err != nil {
        doSomething()
        return err
    }
    ...
}
```

从结构上来看，每一个结构体都可以看成是一棵树，从字段校验的需求来讲，

无论采用深度优先搜索还是广度优先搜索来对这棵结构体树来进行遍历，都是可以的。

利用结构体的 `tag`，通过反射机制对结构体进行树形遍历，实现请求参数的校验，在代码层面是可行的，

但对结构体进行校验时大量使用了反射，而 Go 的反射在性能上不太出众，有时甚至会影响到程序的性能，

这样的考虑确实有一些道理，但需要对结构体进行大量校验的场景往往出现在 Web 服务，

这里并不一定是程序的性能瓶颈所在，实际的效果还是要从 pprof 中做更精确的判断。

<strong>参数校验相关文章，自己也早就整理了一篇<a href="https://eminem-x.github.io/2022/08/18/%E5%90%8E%E7%AB%AF%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/#more">博客</a>，也推荐了其他几种方式，可以参考。</strong>

