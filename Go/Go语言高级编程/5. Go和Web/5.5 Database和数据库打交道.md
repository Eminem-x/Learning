# Database和数据库打交道

Go 官方提供了 `database/sql` 包来给用户进行和数据库打交道的工作，`database/sql` 库实际只提供了一套操作数据库的接口和规范，

例如抽象好的 SQL 预处理，连接池管理，数据绑定，事务，错误处理等等，官方并没有提供具体某种数据库实现的协议支持，

所以和具体的数据库连接时，需要引入各自的驱动包，例如 MySQL：

```go
import "database/sql"
import _ "github.com/go-sql-driver/mysql"

db, err := sql.Open("mysql", "user:password@/dbname")
```

其中第二句语法的作用会调用 `mysql` 包的 `init` 函数：

```go
// 在 sql 包的全局 map 里把 mysql 这个名字的 driver 注册
func init() {
    sql.Register("mysql", &MySQLDriver{})
}
```

可以参考极客兔兔博客里关于 GeeOrm 的实现，`dialect` 的阐述，即每个驱动可以看作一种方言。

## 提高生产效率的 ORM 和 SQL Builder

>对象关系映射（Object Relational Mapping，简称 ORM），用于实现面向对象编程语言里不同类型系统的数据之间的转换。
>
> 从效果上说，它其实是创建了一个可在编程语言里使用的 “虚拟对象数据库”。

ORM 的目的就是屏蔽掉 DB 层，很多语言的 ORM 只要把你的类或结构体定义好，

再用特定的语法将结构体之间的一对一或者一对多关系表达出来，使用 ORM 的时候，往往比较容易有一种忘记了数据库的直观感受，

互联网系统的忌讳之一，就是这种无端的读放大，因此在通过 ORM 时，要避免因懒惰造成的查询，想从设计上隐去太多的细节，

而方便的代价是其背后的运行完全失控，这样的项目在经过几任维护人员之后，将变得面目全非，难以维护，

当然，不能否认 ORM 的进步意义，它的设计初衷就是为了让数据的操作和存储的具体实现相剥离，

但是在上了规模的公司的人们渐渐达成了一个共识，由于隐藏重要的细节，ORM 可能是失败的设计，

其所隐藏的重要细节对于上了规模的系统开发来说至关重要。

<strong>相比 ORM 来说，SQL Builder 在 SQL 和项目可维护性之间取得了比较好的平衡。</strong>

## 脆弱的数据库

无论是 ORM 还是 SQL Builder 都有一个致命的缺点，就是没有办法进行系统上线的事前 sql 审核，

虽然很多 ORM 和 SQL Builder 也提供了运行期打印 sql 的功能，但只在查询的时候才能进行输出，

而 SQL Builder 和 ORM 本身提供的功能太过灵活，使得你不可能通过测试枚举出所有可能在线上执行的 sql：

```go
// 这样的系统只要发布，就已经孕育了初期的巨大风险。
where := map[string]interface{} {
    "product_id = ?" : 10,
    "user_id = ?" : 1232 ,
}

if order_id != 0 {
    where["order_id = ?"] = order_id
}

res, err := historyModel.GetList(where, limit, orderBy)
```

所以现如今，大型的互联网公司核心线上业务都会在代码中把 SQL 放在显眼的位置提供给 DBA 评审，举一个例子：

```go
const (
    getAllByProductIDAndCustomerID = `select * from p_orders where product_id in (:product_id) and customer_id=:customer_id`
)

// GetAllByProductIDAndCustomerID
// @param driver_id
// @param rate_date
// @return []Order, error
func GetAllByProductIDAndCustomerID(ctx context.Context, productIDs []uint64, customerID uint64) ([]Order, error) {
    var orderList []Order

    params := map[string]interface{}{
        "product_id" : productIDs,
        "customer_id": customerID,
    }

    // getAllByProductIDAndCustomerID 是 const 类型的 sql 字符串
    sql, args, err := sqlutil.Named(getAllByProductIDAndCustomerID, params)
    if err != nil {
        return nil, err
    }

    err = dao.QueryList(ctx, sqldbInstance, sql, args, &orderList)
    if err != nil {
        return nil, err
    }

    return orderList, err
}
```

像这样的代码，在上线之前把 DAO 层的变更集的 const 部分直接拿给 DBA 来进行审核，就比较方便了。