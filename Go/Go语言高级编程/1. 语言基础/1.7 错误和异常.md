# 错误和异常

Go 语言的错误处理中，错误是软件包 API 和应用程序用户界面的一个重要组成部分，并且被认为是可以预期的结果；

但异常则是一种非预期的结果，发生异常可能表示程序中存在 bug 或发生了其他不可控的问题，

Go 语言推荐使用 `recover` 函数将内部异常转为错误处理，这使得用户可以真正的关心业务相关的错误处理。

如果某个接口简单地将所有普通的错误当作异常抛出，将会使错误信息杂乱并且没有价值，

捕获异常不是最终的目的，如果异常不可预测，直接输出异常信息是最好的处理方法是。

## 错误处理策略

1. `defer` 语句可以保证函数或方法执行异常后，仍可以进行后续关闭或者必要的处理操作

2. Go 语言中的导出函数一般不抛出异常，一个未受控的异常可以看作是程序的 bug，

   但是对于那些提供类似 Web 服务的框架而言；它们经常需要接入第三方的中间件，为了提高系统的稳定，

   Web 框架一般会通过 `recover` 来防御性地捕获所有处理流程中可能产生的异常，然后将异常转为普通的错误返回

3. Go 语言库的实现习惯: 即使在包内部使用了 `panic`，但是在导出函数时会被转化为明确的错误值

```go
func ParseJSON(input string) (s *Syntax, err error) {
    defer func() {
        if p := recover(); p != nil {
            err = fmt.Errorf("JSON: internal error: %v", p)
        }
    }()
    // ...parser...
}
```

## 获取错误的上下文

业务中为了方便理解，底层实现会将底层的错误重新包装为新的错误类型返回给上层：

```go
if _, err := html.Parse(resp.Body); err != nil {
    return nil, fmt.Errorf("parsing %s as HTML: %v", url,err)
}
```

可以很容易从业务层面理解错误发生的原因。但同时，也丢失了底层最原始的错误类型（只剩下错误描述信息了）。

<strong>为记录这种错误类型在包装的变迁过程中的信息，一般会定义一个辅助的 `WrapError` 函数，包装原始的错误，同时保留原始错误类型。</strong>

1. 为了问题定位的方便，同时也为了能记录错误发生时的函数调用状态，记录完整的函数调用信息
2. 为了支持 RPC 等跨网络的传输，可能要需要将错误序列化为类似 JSON 格式的数据，然后再从这些数据中将错误解码恢复出来

```go

type Error interface {
    Caller() []CallerInfo
    Wraped() []error
    Code() int
    error

    private()
}

type CallerInfo struct {
    FuncName string
    FileName string
    FileLine int
}

func New(msg string) error
func NewWithCode(code int, msg string) error

func Wrap(err error, msg string) error
func WrapWithCode(code int, err error, msg string) error

func FromJson(json string) (Error, error)
func ToJson(err error) string
```

当然错误处理也有一套独特的编码风格，检查某个子函数是否失败后，做相应的处理：

```go
f, err := os.Open("filename.ext")
if err != nil {
    // 失败的情形, 马上返回错误
}

// 正常的处理流程
```

首先是一系列的初始检查，用于防止错误发生，之后是函数的实际逻辑，也是常说的 `if err`，

缺点解释比较冗长，几乎大量出现此格式，但是优势在于便于打印出详细的 `log`，对于服务端还是有优势的。

## 错误的错误返回

Go 语言中的错误时一种接口类型，<strong>接口信息中包含了原始类型和原始的值，只有当类型和值都为空时，接口的值才为 `nil`</strong>。

<strong>其实当接口中类型为空的时候，原始值必然也是空的；反之，当接口对应的原始值为空的时候，接口对应的原始类型并不一定为空的。</strong>

在下面的例子中，试图返回自定义的错误类型，当没有错误的时候返回 `nil`：

```go
func returnsError() error {
    var p *MyError = nil
    if bad() {
        p = ErrBad
    }
    return p // Will always return a non-nil error.
}
```

但是，最终返回的结果其实并非是 `nil`：是一个正常的错误，错误的值是一个 `MyError` 类型的空指针。下面是改进的 `returnsError`：

```go
func returnsError() error {
    if bad() {
        return (*MyError)(err)
    }
    return nil
}
```

<strong>因此，在处理错误返回值的时候，没有错误的返回值最好直接写为 `nil`。</strong>

## 剖析异常

`panic` 支持抛出任意类型的异常（而不仅仅是 `error` 类型的错误），`recover` 函数调用的返回值和 `panic` 函数的输入参数类型一致：

```go
// 函数签名
func panic(interface{})
func recover() interface{}
```

在正常执行流程中是没有异常的，因此在这个流程中执行 `recover` 异常捕获函数始终是返回 `nil`。

另一种是异常流程：当函数调用 `panic` 抛出异常，函数将停止执行后续的普通语句，

但是之前注册的 `defer` 函数调用仍然保证会被正常执行，然后再返回到调用者。

```go
// 两种常见的错误 recover 处理方式
func main() {
    if r := recover(); r != nil {
        log.Fatal(r)
    }

    panic(123)

    if r := recover(); r != nil {
        log.Fatal(r)
    }
}
```

<strong>`recover` 函数调用有着更严格的要求：我们必须在 `defer` 函数中直接调用 `recover`</strong>，

如果 `defer` 中调用的是 `recover` 函数的包装函数的话，异常的捕获工作将失败！

```go
func main() {
		// 下面两种方式都无法捕获 panic 异常
  	defer func() {
        // 无法捕获异常
        if r := MyRecover(); r != nil {
            fmt.Println(r)
        }
    }()
    panic(1)
    
    defer func() {
        defer func() {
            // 无法捕获异常
            if r := recover(); r != nil {
                fmt.Println(r)
            }
        }()
    }()
  
  	// 正确形式
  	defer func() {
        if r := recover(); r != nil { ... }
        // 虽然总是返回 nil, 但是可以恢复异常状态
    }()

    // 警告: 用 nil 为参数抛出异常
    panic(nil)
}
  	
    panic(1)
}

func MyRecover() interface{} {
    log.Println("trace...")
    return recover()
}

```

<strong>必须要和有异常的栈帧只隔一个栈帧，`recover` 函数才能正常捕获异常。</strong>

换言之，`recover` 函数捕获的是祖父一级调用函数栈帧的异常（刚好可以跨越一层 `defer` 函数）！