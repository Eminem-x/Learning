# 1.3 数组、字符串和切片

1. Go 语言数组是一种值类型，虽然元素可以被修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理
2. Go 语言字符串底层数据也是对应的字节数组，但是字符串的只读属性禁止对于元素的修改，因此字符串的赋值只是复制了数据地址和对应长度，而不会导致底层数据的复制
3. 切片的结构和字符串类似，但是解除了只读限制，并且包含独立的长度和容量信息
4.  Go 语言的赋值和函数传参规则，除了闭包函数以引用的方式对外部变量访问之外，其它赋值和函数传参数都是以传值的方式处理

## 数组

#### 组成性质

数组是一个由固定长度的特定类型元素组成的序列，一个数组可以有零或多个元素组成，长度是数组类型的组成部分。

<strong>因为长度是数组类型的一个组成部分，所以不同长度或不同类型的数据组成的数组都是不同的类型：</strong>

```go
// a 和 b 长度不同，无法直接赋值
var a = [...]int{1, 2}
var b = [...]int{1, 2, 3}
a = b // fail

// c 和 d 长度相同，可以直接赋值
var c = [...]int{1, 2}
var d = [...]int{3, 4}
c = d // pass
```

因此在 Go 语言中很少直接使用数组（不同长度的数组因为类型不同无法直接赋值），而是使用切片。

#### 定义方式

```go
var a [3]int                    // 定义长度为 3 的 int 型数组, 元素全部为 0
var b = [...]int{1, 2, 3}       // 定义长度为 3 的 int 型数组, 元素为 1, 2, 3
var c = [...]int{2: 3, 1: 2}    // 定义长度为 3 的 int 型数组, 元素为 0, 2, 3
var d = [...]int{1, 2, 4: 5, 6} // 定义长度为 6 的 int 型数组, 元素为 1, 2, 0, 0, 5, 6
```

其中第三种是以索引的方式来初始化元素，数组长度以出线的最大索引为准，没有明确初始化的元素为零值。

#### 数组指针

Go 语言中数组是值语义。一个数组变量即表示整个数组，它并不是隐式的指向第一个元素的指针（比如 C 语言的数组），而是一个完整的值，因此当数组变量被赋值或传递时，实际上会复制整个数组。如果数组较大，会有比较大的开销，可以使用指针来避免，<strong>但是需要注意，数组指针并不是数组</strong>，通过数组指针操作数组的方式和通过数组本身的操作类似：

```go
var a = [...]int{1, 2, 3} // a 是一个数组
var b = &a                // b 是指向数组的指针

fmt.Println(a[0], a[1])   // 打印数组的前 2 个元素
fmt.Println(b[0], b[1])   // 通过数组指针访问数组元素的方式和数组类似

for i, v := range b {     // 通过数组指针迭代数组的元素
    fmt.Println(i, v)
}
```

<strong>但是数组指针依然不够灵活，因为长度是组成部分，指向不同数组的指针类型也是不完全相同的：</strong>

````go
// a 和 b 长度不同，无法直接赋值
var a = [...]int{1, 2}
var b = [...]int{1, 2, 3}
p1, p2 := &a, &b
p1 = p2 // cannot use p2（type *[6]int) as type *[3]int in assignment

// c 和 d 长度相同，可以直接赋值
var c = [...]int{1, 2}
var d = [...]int{3, 4}
p3, p4 := &c, &d
p3 = p4 // pass
````

#### 遍历数组

内置函数 `len` 和 `cap`，分别计算数组的长度和容量，不过对于数组来说，二者的结果始终一样：

```go
for i := range a {
		fmt.Printf("a[%d]: %d\n", i, a[i])
}
for i, v := range b {
		fmt.Printf("b[%d]: %d\n", i, v)
}
for i := 0; i < len(c); i++ {
		fmt.Printf("c[%d]: %d\n", i, c[i])
}
```

<strong>推荐使用 `for range` 方式迭代，因为这种方式可以保证不会出现数组越界的情形，可以省去对下标越界的判断。</strong>

#### 数组形式

数组不仅仅可以用于数值类型，还可以定义字符串数组、结构体数组、函数数组、接口数组、管道数组等等，

也可以定义一个空的数组：

```go
var a [0]int       // 定义一个长度为 0 的数组
var b = [0]int{}   // 定义一个长度为 0 的数组
var c = [...]int{} // 定义一个长度为 0 的数组
```

空数组虽然很少直接使用，但是可以用于强调某种特有类型的操作时，避免分配额外的内存空间，最常见的管道的同步操作：

```go
c1 := make(chan [0]int)
go func() {
    fmt.Println("c1")
    c1 <- [0]int{}
}()
<-c1
```

当然一般更倾向于用无类型的匿名结构体代替：`c1 <- struct{}{}`

#### 打印数组

可以用 `fmt.Printf` 函数提供的 `%T` 或 `%#v` 谓词语法来打印数组的类型和详细信息：

```go
fmt.Printf("b: %T\n", b)  // b: [3]int
fmt.Printf("b: %#v\n", b) // b: [3]int{1, 2, 3}
```

## 字符串

#### 组成性质

和数组不同的是，字符串的元素不可修改，是一个只读的字节数组，不可改变的字节序列，

<strong>每个字符串的长度虽然是固定的，但是字符串的长度并不是字符串类型的一部分，因此不同于数组赋值，字符串可以直接赋值。</strong>

Go 语言的源代码要求是 `UTF8` 编码，导致出现的字符串面值常量一般也是 `UTF8` 编码，而源代码中的文本字符串通常被解释为采用 `UTF8` 编码的 `Unicode` 码点 （`rune` ）序列，因为底层为字节序列，所以可以包含任意的数据，可以用字符串表示 `GBK` 等非 `UTF8` 的编码数据，但此时 `for range` 语法并不支持遍历。

#### 底层结构

Go 语言字符串的底层结构在 `reflect.StringHeader` 中定义：

```go
type StringHeader struct {
    Data uintptr // 字符串指向的底层字节数组
    Len  int // 字符串的字节长度
}
```

字符串其实是一个结构体，因此其赋值操作也就是 `reflect.StringHeader` 结构体的复制过程，并不会涉及底层字节数组的复制。

值得注意的是：<strong>`Len` 是字符串的字节长度</strong>，因此中英文对应的长度并不相同：

```go
s1 := "一二三"
s2 := "123"
fmt.Println(len(s1)) // 9
fmt.Println(len(s2)) // 3
```

<strong>而底层对应的是字节数组</strong>，所以字符串底层数据和数组是完全一致的：

```go
s := "hello, world"
var data = [...]byte{
    'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd',
}
```

#### 编码方式

我们一般都会假设字符串对应的是一个合法的 UTF8 编码的字符序列。可以用内置的 `print` 调试函数或 `fmt.Print` 函数直接打印，

<strong>也可以用 `for range` 循环直接遍历 UTF8 解码后的 Unicode 码点值：</strong>

```go
s1 := "一二三"
// 19968 20108 19977
for _, v := range s1 {
		fmt.Println(v)
}

s2 := "123一二三"
// 49 50 51 19968 20108 19977
for _, v := range s2 {
		fmt.Println(v)
}
```

以下面为例，通过打印转型为字节类型来查看字符底层对应的数据：

```go
fmt.Printf("%#v\n", []byte("Hello, 世界"))
// []byte{0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0xe4, 0xb8, 0x96, 0xe7, 0x95, 0x8c}
```

Go 语言除了 `for range` 语法对 UTF8 字符串提供了特殊支持外，还对字符串和 `[]rune` 类型的相互转换提供了特殊的支持，

这里的 `rune` 只是 `int32` 类型的别名，并不是重新定义的类型。`rune` 用于表示每个 Unicode 码点，目前只使用了 21 个 bit 位。

字符串相关的强制类型转换主要涉及到 `[]byte` 和 `[]rune` 两种类型。每个转换都可能隐含重新分配内存的代价，

最坏的情况下它们的运算时间复杂度都是 `O(n)`，<strong>因此如果处理中文字符串，尽量使用 `[]rune` 类型，避免不一致.</strong>

<strong>常见的转换方式：`[]byte(s)`，`string(bytes)`，`[]rune(s)`，`string(runes)`</strong>。

## 切片

#### 组成性质

简单来说，切片就是一种简化版的动态数组，因为动态数组的长度是不固定的，切片的长度自然也就不是其类型的组成部分，关于这一点可以参考上面数组和字符串的比较，因此切片的使用更加广泛。

```go
// reflect.SliceHeader
type SliceHeader struct {
    Data uintptr // 指向的底层数组
    Len  int     // 长度
    Cap  int     // 最大容量
}
```

在对切片本身赋值或参数传递时，和数组指针的操作方式类似，<strong>只复制切片头信息（`reflect.SliceHeader`），不会复制底层的数据，</strong>

对于类型，和数组的最大不同是，切片的类型和长度信息无关，只要是相同类型元素构成的切片均对应相同的切片类型。

#### 定义方式

```go
var (
    a []int               // nil 切片, 和 nil 相等, 一般用来表示一个不存在的切片
    b = []int{}           // 空切片, 和 nil 不相等, 一般用来表示一个空的集合
    c = []int{1, 2, 3}    // 有 3 个元素的切片, len 和 cap 都为 3
    d = c[:2]             // 有 2 个元素的切片, len 为 2, cap 为 3
    e = c[0:2:cap(c)]     // 有 2 个元素的切片, len 为 2, cap 为 3
    f = c[:0]             // 有 0 个元素的切片, len 为 0, cap 为 3
    g = make([]int, 3)    // 有 3 个元素的切片, len 和 cap 都为 3
    h = make([]int, 2, 3) // 有 2 个元素的切片, len 为 2, cap 为 3
    i = make([]int, 0, 3) // 有 0 个元素的切片, len 为 0, cap 为 3
)
```

<strong>切片可以和 `nil` 进行比较，只有当切片底层数据指针为空时切片本身为 `nil`，</strong>这时候切片的长度和容量信息将是无效的。

如果有切片的底层数据指针为空，但是长度和容量不为 0 的情况，那么说明切片本身已经被损坏了

（比如直接通过 `reflect.SliceHeader` 或 `unsafe` 包对切片作了不正确的修改）。

#### 修改方式

