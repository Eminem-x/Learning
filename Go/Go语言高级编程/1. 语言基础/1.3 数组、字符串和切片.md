# 1.3 数组、字符串和切片

1. Go 语言数组是一种值类型，虽然元素可以被修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理
2. Go 语言字符串底层数据也是对应的字节数组，但是字符串的只读属性禁止对于元素的修改，因此字符串的赋值只是复制了数据地址和对应长度，而不会导致底层数据的复制
3. 切片的结构和字符串类似，但是解除了只读限制，并且包含独立的长度和容量信息
4.  Go 语言的赋值和函数传参规则，除了闭包函数以引用的方式对外部变量访问之外，其它赋值和函数传参数都是以传值的方式处理

## 数组

#### 组成性质

数组是一个由固定长度的特定类型元素组成的序列，一个数组可以有零或多个元素组成，长度是数组类型的组成部分。

<strong>因为长度是数组类型的一个组成部分，所以不同长度或不同类型的数据组成的数组都是不同的类型：</strong>

```go
// a 和 b 长度不同，无法直接赋值
var a = [...]int{1, 2}
var b = [...]int{1, 2, 3}
a = b // fail

// c 和 d 长度相同，可以直接赋值
var c = [...]int{1, 2}
var d = [...]int{3, 4}
c = d // pass
```

因此在 Go 语言中很少直接使用数组（不同长度的数组因为类型不同无法直接赋值），而是使用切片。

#### 定义方式

```go
var a [3]int                    // 定义长度为 3 的 int 型数组, 元素全部为 0
var b = [...]int{1, 2, 3}       // 定义长度为 3 的 int 型数组, 元素为 1, 2, 3
var c = [...]int{2: 3, 1: 2}    // 定义长度为 3 的 int 型数组, 元素为 0, 2, 3
var d = [...]int{1, 2, 4: 5, 6} // 定义长度为 6 的 int 型数组, 元素为 1, 2, 0, 0, 5, 6
```

其中第三种是以索引的方式来初始化元素，数组长度以出线的最大索引为准，没有明确初始化的元素为零值。

#### 数组指针

Go 语言中数组是值语义。一个数组变量即表示整个数组，它并不是隐式的指向第一个元素的指针（比如 C 语言的数组），而是一个完整的值，因此当数组变量被赋值或传递时，实际上会复制整个数组。如果数组较大，会有比较大的开销，可以使用指针来避免，<strong>但是需要注意，数组指针并不是数组</strong>，通过数组指针操作数组的方式和通过数组本身的操作类似：

```go
var a = [...]int{1, 2, 3} // a 是一个数组
var b = &a                // b 是指向数组的指针

fmt.Println(a[0], a[1])   // 打印数组的前 2 个元素
fmt.Println(b[0], b[1])   // 通过数组指针访问数组元素的方式和数组类似

for i, v := range b {     // 通过数组指针迭代数组的元素
    fmt.Println(i, v)
}
```

<strong>但是数组指针依然不够灵活，因为长度是组成部分，指向不同数组的指针类型也是不完全相同的：</strong>

````go
// a 和 b 长度不同，无法直接赋值
var a = [...]int{1, 2}
var b = [...]int{1, 2, 3}
p1, p2 := &a, &b
p1 = p2 // cannot use p2（type *[6]int) as type *[3]int in assignment

// c 和 d 长度相同，可以直接赋值
var c = [...]int{1, 2}
var d = [...]int{3, 4}
p3, p4 := &c, &d
p3 = p4 // pass
````

#### 遍历数组

内置函数 `len` 和 `cap`，分别计算数组的长度和容量，不过对于数组来说，二者的结果始终一样：

```go
for i := range a {
		fmt.Printf("a[%d]: %d\n", i, a[i])
}
for i, v := range b {
		fmt.Printf("b[%d]: %d\n", i, v)
}
for i := 0; i < len(c); i++ {
		fmt.Printf("c[%d]: %d\n", i, c[i])
}
```

<strong>推荐使用 `for range` 方式迭代，因为这种方式可以保证不会出现数组越界的情形，可以省去对下标越界的判断。</strong>

#### 数组形式

数组不仅仅可以用于数值类型，还可以定义字符串数组、结构体数组、函数数组、接口数组、管道数组等等，

也可以定义一个空的数组：

```go
var a [0]int       // 定义一个长度为 0 的数组
var b = [0]int{}   // 定义一个长度为 0 的数组
var c = [...]int{} // 定义一个长度为 0 的数组
```

空数组虽然很少直接使用，但是可以用于强调某种特有类型的操作时，避免分配额外的内存空间，最常见的管道的同步操作：

```go
c1 := make(chan [0]int)
go func() {
    fmt.Println("c1")
    c1 <- [0]int{}
}()
<-c1
```

当然一般更倾向于用无类型的匿名结构体代替：`c1 <- struct{}{}`

#### 打印数组

可以用 `fmt.Printf` 函数提供的 `%T` 或 `%#v` 谓词语法来打印数组的类型和详细信息：

```go
fmt.Printf("b: %T\n", b)  // b: [3]int
fmt.Printf("b: %#v\n", b) // b: [3]int{1, 2, 3}
```

----

